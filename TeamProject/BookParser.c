

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term() {
    printf("Enter <term>\n");
/* Parse the first factor */
    factor();
/* As long as the next token is * or /, get the
next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of funct

/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr() {
    printf("Enter <expr>\n");
/* Parse the first term */
    term();
/* As long as the next token is + or -, get
the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }
    printf("Exit <expr>\n");
} /* End of function expr */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void factor() {
    printf("Enter <factor>\n");
/* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)
/* Get the next token */
        lex();
/* If the RHS is ( <expr> ), call lex to pass over the
left parenthesis, call expr, and check for the right
parenthesis */
    else {
        if (nextToken == LEFT_PAREN) {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                error();
        } /* End of if (nextToken == ... */
/* It was not an id, an integer literal, or a left
parenthesis */
        else error();
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */


/* Function ifstmt
Parses strings in the language generated by the rule:
<ifstmt> -> if (<boolexpr>) <statement>
[else <statement>]
*/
void ifstmt() {
/* Be sure the first token is 'if' */
    if (nextToken = IF_CODE)
        error();
    else {
/* Call lex to get to the next token */
        lex();
/* Check for the left parenthesis */
        if (nextToken = LEFT_PAREN)
            error();
        else {
/* Parse the Boolean expression */
            boolexpr();
/* Check for the right parenthesis */
if (nextToken = RIGHT_PAREN)
error();
else {
/* Parse the then clause */
statement();
/* If an else is next, parse the else clause */
if (nextToken == ELSE_CODE) {
/* Call lex to get over the else */
lex();
statement();
} /* end of if (nextToken == ELSE_CODE ... */
} /* end of else of if (nextToken != RIGHT ... */
} /* end of else of if (nextToken != LEFT ... */
} /* end of else of if (nextToken != IF_CODE ... */
} /* end of ifstmt */

/*
  Input should be: (sum + 47) / total
  Desired output: 
Next token is: 25 Next lexeme is (
Next token is: 11 Next lexeme is sum
Next token is: 21 Next lexeme is +
Next token is: 10 Next lexeme is 47
Next token is: 26 Next lexeme is )
Next token is: 24 Next lexeme is /
Next token is: 11 Next lexeme is total
Next token is: -1 Next lexeme is EOF
*/

/* Parser functions */

void expr() {
    term();
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        nextToken = lex(); // Get the next token from the lexical analyzer
        term();
    }
}

void term() {
    factor();
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
        nextToken = lex(); // Get the next token from the lexical analyzer
        factor();
    }
}

void factor() {
    if (nextToken == IDENT || nextToken == INT_LIT) {
        nextToken = lex(); // Get the next token from the lexical analyzer
    } else if (nextToken == LEFT_PAREN) {
        nextToken = lex(); // Get the next token from the lexical analyzer
        expr();
        if (nextToken == RIGHT_PAREN) {
            nextToken = lex(); // Get the next token from the lexical analyzer
        } else {
            printf("Error: ')' expected\n");
            // Handle error: ')' expected
        }
    } else {
        printf("Error: Unexpected token\n");
        // Handle error: Unexpected token
    }
}



